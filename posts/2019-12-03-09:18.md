# SQL for ETL: Templates or EDSL

Should you use templates or an EDSL[^1] for the SQL that makes up the "T" step of
your ETL (or ELT) pipeline?

[^1]: Embedded Domain-Specific Language

I'm currently leaning toward using an EDSL, but I haven't actually tried it in
anger, so I thought I'd write my thoughts out here.

## Context

In an ELT pipeline, you load a bunch of data from internal and third-party
sources into your warehouse, doing the minimum amount of transformation
required to turn the JSON & CSV blobs you get into rows in a table.

This is all fine and dandy, but basically no one in your organization will be
able to use it. Querying each source requires weird, near useless knowledge of
that sources idiosyncracies. For example, you might take both PayPal and
Stripe payments. In order to understand how much money you're making, you'd
have to understand both PayPal and Stripe's internal data model. Yuck.

And even if people in your organization *can* use the data sources, they'd end
up doing the same queries over and over again.

Further, there'll be inconsistencies between sources and bugs within sources
that need to be cleaned up.

All of this is the responsibility of the "T" step of the ELT pipeline:
transforming information that's already in tables into other tables that are
more useful to your business.

## Is SQL necessary?

The obvious way to transforming data in a relational database is to use SQL.
For all of its warts, it's a pretty effective tool. In analytics databases
like Redshift and BigQuery, you have access to windowing functions that make
things like
[sessionizing](https://segment.com/blog/using-sql-to-define-measure-and-analyze-user-sessions/)
possible.

There are also other ways, but I've been deliberately avoiding learning much
about them so I can crack on with the task at hand. In this space, it's worth
mentioning Apache Beam, MapReduce, and Hadoop.

For the rest of this post, I'm going to assume SQL.

## How to write SQL

The bones of the transformation will be in SQL, and will be executed by the
database. That's a given.

The question is, how do you actually write the SQL? Or, more specifically,
what do you store in your Git repository?

When I'm figuring out a transformation, it's very natural to hand-write some
SQL and iterate on it in DataGrip or the BigQuery console. The near-instant
feedback is invaluable, and not being concerned about writing maintainable
code makes it easier to solve the puzzle of the transformation.

However, I must write maintainable code, as I am the poor sucker who must
maintain it. So the SQL needs to make its way out of DataGrip and into a Git
repository.

When it does, you've generally got two choices: templates or EDSL.

### Templates

Here's what a SQL template might look like:

```sql
SELECT
  platform,
  COUNT(*) AS num_events
FROM `{{ event_table }}`
WHERE
  _PARTITIONDATE = @date
GROUP BY platform
```

This query counts the number of events per platform on a given day. It has one
template parameter: the name of the event table, and one query parameter.

When you want to run this query in Python, you'll do something like this:

```python
env = jinja.Environment(...)
query = env.render_template("events_per_day.sql", {"event_table": "android.tracks"})
db_conn.query(query, date=date.today())
```

### EDSL

SQL is a DSL. It's a domain-specific language for transforming data in tables.

An EDSL is a domain-specific language that has been embedded into another
full-featured programming language.

TODO(jml): Mention Linq

TODO(jml): Link to SQLalchemy

Probably the most widely used SQL EDSL in Python is SQLalchemy[^2]. You could
write the above query in SQLalchemy like this:

[^2]: SQLalchemy also comes with an ORM. ORMs are awful, so we're going to ignore that.

```python
import sqlalchemy as db

def events_per_day(table, date):
    return (
        db.select([table.c.platform, count("*").label("num_events")])
        .where(table.c._PARTITIONDATE = date)
        .group_by(table.c.platform)
    )
```

And when you want to run the query, you'll write something like:

TODO(jml): How to run SQLalchemy queries

```python

```
